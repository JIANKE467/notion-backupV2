重构分两个部分

1.定义（实现原理）：各种大类要包括分出来的小类。如：线性表要知道下属类别：顺序表和其下属类别：顺序表插入/静态分配

> 注重实现方法，代码用文字描述

> 每个最小页面内用函数分类，一个函数写一块，写出总结：将什么几个功能写成几个个函数？画一个层级图

2.实现（实现代码）

> 注重代码，用链接链接到1，写出代码，同样一个函数写一块

```plain text
数据结构
│
├── 一、绪论
│     ├── 数据结构三要素
│     │     ├ 数据的逻辑结构
│     │     ├ 数据的存储结构
│     │     └ 数据的运算
│     ├── 四种逻辑结构
│     │     ├ 集合
│     │     ├ 线性结构
│     │     ├ 树形结构
│     │     └ 图结构
│     └── 常用时间复杂度
│           ├O(1)  
│           ├O(n)
│           ├O(n log n)
│           └O(n²)
│
├── 二、线性表  ★重点
│     ├ 顺序表
│     ├ 链表
│     │     ├ 单链表
│     │     ├ 双链表
│     │     └ 循环链表
│     ├ 基本操作
│     │     ├ 插入（移动/指针）
│     │     ├ 删除
│     │     └ 查找
│     └ 与链表比较（时间/空间/效率）
│
├── 三、栈与队列 ★高频
│     ├ 栈（后进先出）
│     │     ├ 入栈/出栈
│     │     └ 表达式求值
│     ├ 队列（先进先出）
│     └ 循环队列（判空判满）
│
├── 四、串（了解）
│     ├ BF匹配
│     ├ KMP
│     │     └ next数组
│     └ 模式匹配复杂度
│
├── 五、树与二叉树 ★大题区
│     ├ 二叉树概念
│     │     ├ 满
│     │     ├ 完全
│     │     └ 性质
│     ├ 遍历
│     │     ├ 先
│     │     ├ 中
│     │     ├ 后
│     │     └ 层次
│     ├ 二叉排序树
│     └ 平衡树AVL
│
├── 六、图  ★难点
│     ├ 邻接矩阵
│     ├ 邻接表
│     ├ DFS
│     ├ BFS
│     ├ 最小生成树
│     │     ├ Prim
│     │     └ Kruskal
│     └ 最短路径
│           ├ Dijkstra
│           └ Floyd
│
├── 七、查找
│     ├ 顺序查找
│     ├ 折半查找
│     ├ 二叉排序树
│     ├ AVL树
│     ├ 哈希表
│     │     └ 冲突处理：链地址/开放地址
│
└── 八、排序 ★考得最多
      ├ 内部排序
      │   ├ 冒泡
      │   ├ 选择
      │   ├ 插入
      │   ├ 快排
      │   ├ 归并
      │   └ 堆排
      ├ 时间复杂度
      └ 稳定性
```


[Child page: 线性表](./线性表.md)

