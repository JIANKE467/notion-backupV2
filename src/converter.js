import { extFromUrl, richTextToPlain } from "./util.js"; import path from "path";

// Very small helper to join rich text with basic formatting function renderRichText(rts) { if (!rts) return ""; return rts.map(t => { let txt = t.plain_text || ""; if (t.annotations) { if (t.annotations.code) txt = \${txt}`; if (t.annotations.bold) txt = ${txt}; if (t.annotations.italic) txt = ${txt}; if (t.annotations.strikethrough) txt = ; if (t.annotations.underline) txt = <u>${txt}</u>; } if (t.href) txt = ${txt}`; return txt; }).join(""); }

export async function pageToMarkdown(notionClient, pageId, opts = {}) { // opts: downloadAssets:boolean, pageDir:string, assetsDir:string, perPageImages:boolean const downloadAssets = !!opts.downloadAssets; const pageDir = opts.pageDir || "."; const assetsDir = opts.assetsDir || "assets"; const perPage = !!opts.perPageImages;

const blocks = []; let cursor = undefined; while (true) { const res = await notionClient.getBlockChildren(pageId, cursor); blocks.push(...res.results); if (!res.has_more) break; cursor = res.next_cursor; }

let md = "";

for (const block of blocks) { const t = block.type; const b = block[t]; switch (t) { case "paragraph": md += renderRichText(b.rich_text) + "\n\n"; break; case "heading_1": md += # ${renderRichText(b.rich_text)}\n\n; break; case "heading_2": md += ## ${renderRichText(b.rich_text)}\n\n; break; case "heading_3": md += ### ${renderRichText(b.rich_text)}\n\n; break; case "bulleted_list_item": md += - ${renderRichText(b.rich_text)}\n; break; case "numbered_list_item": md += 1. ${renderRichText(b.rich_text)}\n; break; case "to_do": md += - [${b.checked ? "x" : " "}] ${renderRichText(b.rich_text)}\n; break; case "quote": md += > ${renderRichText(b.rich_text)}\n\n; break; case "code": md += "" + (b.language || "") + "\n" + renderRichText(b.rich_text) + "\n\n\n"; break; case "divider": md += "---\n\n"; break; case "image": { const url = b.type === "external" ? b.external.url : b.file.url; const ext = extFromUrl(url) || ".jpg"; const name = img_${block.id}${ext}; const relDir = perPage ? path.join("images") : assetsDir; const dest = perPage ? path.join(pageDir, relDir, name) : path.join(assetsDir, name); if (downloadAssets) { try { await opts.downloader.download(url, dest); } catch (e) { console.warn(image download failed: ${url} -> ${dest}, e.message); } } const mdPath = perPage ? ./${relDir}/${name} : ./${relDir}/${name}; md += ![image](${mdPath})\n\n; break; } case "child_page": md += \n[Child page: ${b.title}](./${b.title}.md)\n\n; break; default: // unsupported types are skipped or could be extended break; } }

return md; }
